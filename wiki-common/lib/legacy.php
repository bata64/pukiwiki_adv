<?php
// PukiWiki Advance - Yet another WikiWikiWeb clone
// $Id: auth.php,v 1.0 2012/09/25 15:31:00 Logue Exp $
// Copyright (C)
//   2012      PukiWiki Advance Developers Team
// License: GPL v2 or (at your option) any later version
//
// old functions

use PukiWiki\Lib\File\FileFactory;
use PukiWiki\Lib\File\WikiFile;
use PukiWiki\Lib\Renderer\RendererFactory;
use PukiWiki\Lib\Renderer\Inline\Inline;
use PukiWiki\Lib\Relational;

/**
 * backup.php
 */
function make_backup($page, $delete = FALSE)
{
	global $del_backup;
	if (empty($page)) return;
	$backup = new PukiWiki\Lib\File\BackupFile($page);

	if ($del_backup && $delete) {
		$backup->removeBackup();
		return;
	}
	return $backup->setBackup();
}

function get_backup($page, $age = 0)
{
	if (empty($page)) return;
	return FileFactory::Backup($page)->getBackup($age);
}

function _backup_file_exists($page){
	$backup = new PukiWiki\Lib\BackupFile($page);
	return $backup->has();
}
/**
 * convert_html.php
 */
function convert_html($lines)
{
	global $vars, $digest;
	static $contents_id = 0;

	// Set digest
	if (empty($digest) && !empty($vars['page'])){
		$digest = FileFactory::Wiki($vars['page'])->digest();
	}

	if (! is_array($lines)) $lines = explode("\n", $lines);

	return RendererFactory::factory($lines);
}
/**
 * file.php
 */
function get_source($page = NULL, $lock = TRUE, $join = FALSE)
{
	if (empty($page)) return;
	$wiki = new WikiFile($page);
	if (!$wiki->has()){
		return;
	}
	return $wiki->get($join);
}

// Get last-modified filetime of the page
function get_filetime($page)
{
	if (empty($page)) return;
	return FileFactory::Wiki($page)->getTime();
}

// Get physical file name of the page
function get_filename($page)
{
	if (empty($page)) return;
	return FileFactory::Wiki($page)->filename;
}

// Get elapsed date of the page
function get_pg_passage($page, $sw = TRUE)
{
	if (empty($page)) return;
	return FileFactory::Wiki($page)->passage($sw, false);
}

// Put a data(wiki text) into a physical file(diff, backup, text)
function page_write($page, $postdata, $notimestamp = FALSE)
{
	if (empty($page)) return;
	$wiki = new WikiFile($page);
	if ($notimestamp){
		$timestamp = $wiki->getTime();
		$wiki->set($postdata);
		$wiki->setTime($timestamp);
	}else{
		$wiki->set($postdata);
	}
}

// Get a list of related pages of the page
function links_get_related($page)
{
	global $vars, $related;
	static $links;

	if (empty($page)) return;

	if (isset($links[$page])) return $links[$page];

	// If possible, merge related pages generated by make_link()
	$links[$page] = ($page === $vars['page']) ? $related : array();

	// Get repated pages from DB
	$links = new Relational($page);
	//$links[$page] += links_get_related_db($page);
	$links[$page] = $link->get_related();

	return $links[$page];
}

// Update PKWK_MAXSHOW_CACHE itself (Add or renew about the $page) (Light)
// Use without $autolink
function lastmodified_add($update = '', $remove = '')
{
	// global $maxshow, $whatsnew, $autolink;
	global $maxshow, $whatsnew, $autolink, $autobasealias;
	global $cache;

	// AutoLink implimentation needs everything, for now
	//if ($autolink) {
	if ($autolink || $autobasealias) {
		put_lastmodified(); // Try to (re)create ALL
		return;
	}

	if (($update == '' || check_non_list($update)) && $remove == '')
		return; // No need

	// Check cache exists
	if (! $cache['wiki']->hasItem(PKWK_MAXSHOW_CACHE)){
		put_lastmodified(); // Try to (re)create ALL
		return;
	}else{
		$recent_pages = $cache['wiki']->getItem(PKWK_MAXSHOW_CACHE);
	}

	// Remove if it exists inside
	if (isset($recent_pages[$update])) unset($recent_pages[$update]);
	if (isset($recent_pages[$remove])) unset($recent_pages[$remove]);

	// Add to the top: like array_unshift()
	// if ($update != '')
	if ($update != '' && $update != $whatsnew && ! check_non_list($update))
		$recent_pages = array($update => get_filetime($update)) + $recent_pages;

	// Check
	$abort = count($recent_pages) < $maxshow;

	// Update cache
	$cache['wiki']->setItem(PKWK_MAXSHOW_CACHE, $recent_pages);

	if ($abort) {
		put_lastmodified(); // Try to (re)create ALL
		return;
	}

	// ----
	// Update the page 'RecentChanges'

	$recent_pages = array_splice($recent_pages, 0, $maxshow);
	$file = get_filename($whatsnew);

	// Open
	pkwk_touch_file($file);
	$fp = fopen($file, 'r+') or
		die_message('Cannot open ' . htmlsc($whatsnew));
	set_file_buffer($fp, 0);
	flock($fp, LOCK_EX);

	// Recreate
	ftruncate($fp, 0);
	rewind($fp);

	foreach ($recent_pages as $_page=>$time)
		fputs($fp, '- &epoch('.$time.');' .
			' - ' . '[[' . htmlsc($_page) . ']]' . "\n");

	fputs($fp, '#norelated' . "\n"); // :)

	ignore_user_abort($last);	// Plus!

	flock($fp, LOCK_UN);
	fclose($fp);
}

// Re-create PKWK_MAXSHOW_CACHE (Heavy)
function put_lastmodified()
{
	// global $maxshow, $whatsnew, $autolink;
	global $maxshow, $whatsnew, $autolink, $autobasealias;
	global $cache;

	// if (PKWK_READONLY) return; // Do nothing
	if (auth::check_role('readonly')) return; // Do nothing

	// Get WHOLE page list
	$pages = get_existpages();

	// Check ALL filetime
	$recent_pages = array();
	foreach($pages as $page)
		$wiki = FileFactory::Wiki($page);
		if ($page !== $whatsnew && ! check_non_list($page))
			$recent_pages[$page] = $wiki->getTime();

	// Sort decending order of last-modification date
	arsort($recent_pages, SORT_NUMERIC);

	// Cut unused lines
	// BugTrack2/179: array_splice() will break integer keys in hashtable
	$count   = $maxshow + PKWK_MAXSHOW_ALLOWANCE;
	$_recent = array();
	foreach($recent_pages as $key=>$value) {
		unset($recent_pages[$key]);
		$_recent[$key] = $value;
		if (--$count < 1) break;
	}
	$recent_pages = & $_recent;

	// Save to recent cache data
	$cache['wiki']->setItem(PKWK_MAXSHOW_CACHE, $recent_pages);

	// Create RecentChanges
	foreach (array_keys($recent_pages) as $page) {
		$buffer[] = '-&epoch(' . $recent_pages[$page] . '); - [[' . htmlsc($page) . ']]';
	}
	$file = FileFactory::Wiki($whatsnew);
	$file->set(join("\n",$buffer));

	// For AutoLink
	if ($autolink){
		$cache['wiki']->setItem(PKWK_AUTOLINK_REGEX_CACHE, get_autolink_pattern($pages, $autolink));
	}

	// AutoBaseAlias (Plus!)
	if ($autobasealias) {
		$cache['wiki']->setItem(PKWK_AUTOBASEALIAS_CACHE, get_autobasealias($pages));
	}
}

// touch() with trying pkwk_chown()
function pkwk_touch_file($filename, $time = FALSE, $atime = FALSE)
{
	return FileFactory::Generic($filename)->touch($time, $atime);
}

// Get PageReading(pronounce-annotated) data in an array()
function get_readings()
{
	global $pagereading_enable, $pagereading_config_page, $mecab_path;
	global $pagereading_config_dict;

	$pages = get_existpages();

	$readings = array();
	foreach ($pages as $page)
		$readings[$page] = '';

	$deletedPage = FALSE;
	$matches = array();
	$w = new WikiFile($pagereading_config_page);
	foreach ($w->source() as $line) {
		$line = chop($line);
		if(preg_match('/^-\[\[([^]]+)\]\]\s+(.+)$/', $line, $matches)) {
			if(isset($readings[$matches[1]])) {
				// This page is not clear how to be pronounced
				$readings[$matches[1]] = $matches[2];
			} else {
				// This page seems deleted
				$deletedPage = TRUE;
			}
		}
	}

	// If enabled ChaSen/KAKASI execution
	if($pagereading_enable) {

		// Check there's non-clear-pronouncing page '
		$unknownPage = FALSE;
		foreach ($readings as $page => $reading) {
			if(empty($reading)) {
				$unknownPage = TRUE;
				break;
			}
		}

		if($unknownPage) {
			if (file_exists($mecab_path)){
				foreach ($readings as $page => $reading) {
					if(!empty($reading)) continue;
					$readings[$page] = mecab_reading($page);
				}
			}else{
				$patterns = $replacements = $matches = array();
				$d = new WikiFile($pagereading_config_dict);
				foreach ($d->source() as $line) {
					$line = chop($line);
					if(preg_match('|^ /([^/]+)/,\s*(.+)$|', $line, $matches)) {
						$patterns[]     = $matches[1];
						$replacements[] = $matches[2];
					}
				}
				foreach ($readings as $page => $reading) {
					if(!empty($reading)) continue;

					$readings[$page] = $page;
					foreach ($patterns as $no => $pattern)
						$readings[$page] = mb_convert_kana(mb_ereg_replace($pattern,
							$replacements[$no], $readings[$page]), 'aKCV');
				}
			}
		}

		if($unknownPage || $deletedPage) {
			asort($readings, SORT_STRING); // Sort by pronouncing(alphabetical/reading) order
			$body = '';
			foreach ($readings as $page => $reading)
				$body .= '-[[' . $page . ']] ' . $reading . "\n";

			$w->set($body);
		}
	}

	// Pages that are not prounouncing-clear, return pagenames of themselves
	foreach ($pages as $page) {
		if ( empty($readings[$page]) ) $readings[$page] = $page;
	}

	return $readings;
}

// Last-Modified header
function header_lastmod($page = NULL)
{
	global $lastmod;

	if ($lastmod && is_page($page)) {
		pkwk_headers_sent();
		header('Last-Modified: ' .
			date('D, d M Y H:i:s', get_filetime($page)) . ' GMT');
	}
}

// Get a list of encoded files (must specify a directory and a suffix)
function get_existfiles($dir = DATA_DIR, $ext = '.txt')
{
	$aryret = array();
	$pattern = '/^(?:[0-9A-F]{2})+' . preg_quote($ext, '/') . '$/';

	$handle = opendir($dir);
	if ($handle) {
		while (false !== ($entry = readdir($handle))) {
			if (preg_match($pattern, $entry)) {
				$aryret[] = $dir . $entry;
			}
		}
		closedir($handle);
	}else{
		die_message($dir . ' is not found or not readable.');
	}

	$pages[$dir][$ext] = $aryret;
	return $aryret;
}

// Get a page list of this wiki
function get_existpages($dir = DATA_DIR, $ext = '.txt')
{
	// get_existpages を３行で軽くする
	// http://lsx.sourceforge.jp/?Hack%2Fget_existpages
	// ただし、Adv.の場合ファイルに別途キャッシュしているのであまり意味ないかも・・・。
	static $pages;
	if (isset($pages[$dir][$ext])) return $pages[$dir][$ext];

	$aryret = array();
	$pattern = '/^((?:[0-9A-F]{2})+)' . preg_quote($ext, '/') . '$/';

	$matches = array();
	$handle = opendir($dir);
	if ($handle) {
		while (false !== ($entry = readdir($handle))) {
			if (preg_match($pattern, $entry, $matches)) {
				$aryret[$entry] = decode($matches[1]);
			}
		}
		closedir($handle);
	}else{
		die_message($dir . ' is not found or not readable.');
	}
	$pages[$dir][$ext] = $aryret;

	return $aryret;
}

/**
 * func.php
 */
function is_interwiki($str)
{
	global $InterWikiName;
	return preg_match('/^' . $InterWikiName . '$/', $str);
}

function is_pagename($page)
{
	if (empty($page)) return false;
	return FileFactory::Wiki($page)->is_valied();
}

// If the page exists
function is_page($page, $clearcache = FALSE)
{
	if (empty($page)) return false;
	return FileFactory::Wiki($page)->has();
	
}

function is_editable($page)
{
	if (empty($page)) return false;
	return FileFactory::Wiki($page)->is_editable();
}

function is_freeze($page, $clearcache = FALSE)
{
	if (empty($page)) return false;
	return FileFactory::Wiki($page)->is_freezed();
}

// Handling $non_list
// $non_list will be preg_quote($str, '/') later.
function check_non_list($page = '')
{
	if (empty($page)) return false;
	return FileFactory::Wiki($page)->is_hidden();
}

/**
 * links.php
 */
function links_get_related_db($page)
{
	if (empty($page)) return false;
	$relational = new Relational($page);
	return $relational->get_related();
}

// Init link cache (Called from link plugin)
function links_init()
{
	$links = new Relational('');
	return $links->init();
}

// Update link-relationships between pages
function links_update($page)
{
	if (empty($page)) return false;
	$links = new Relational($page);
	return $links->update();
}
/**
 * make_link.php
 */
use PukiWiki\Lib\Renderer\InlineConverter;
// Hyperlink decoration
function make_link($string, $page = '')
{
	global $vars;
	static $converter;

	if (! isset($converter)){ $converter = new InlineConverter(); }

	$clone = $converter->get_clone($converter);

	return $clone->convert($string, ($page !== '') ? $page : $vars['page']);
}


// Make hyperlink for the page
function make_pagelink($page, $alias = '', $anchor = '', $refer = '', $isautolink = FALSE)
{
	return Inline::make_pagelink($page, $alias = '', $anchor = '', $refer = '', $isautolink = FALSE);
}

// Resolve relative / (Unix-like)absolute path of the page
function get_fullname($name, $refer)
{
	global $defaultpage;

	// 'Here'
	if ($name == '' || $name == './') return $refer;

	// Absolute path
	if ($name{0} == '/') {
		$name = substr($name, 1);
		return ($name == '') ? $defaultpage : $name;
	}

	// Relative path from 'Here'
	if (substr($name, 0, 2) == './') {
		$arrn    = preg_split('#/#', $name, -1, PREG_SPLIT_NO_EMPTY);
		$arrn[0] = $refer;
		return join('/', $arrn);
	}

	// Relative path from dirname()
	if (substr($name, 0, 3) == '../') {
		$arrn = preg_split('#/#', $name,  -1, PREG_SPLIT_NO_EMPTY);
		$arrp = preg_split('#/#', $refer, -1, PREG_SPLIT_NO_EMPTY);

		while (! empty($arrn) && $arrn[0] == '..') {
			array_shift($arrn);
			array_pop($arrp);
		}
		$name = ! empty($arrp) ? join('/', array_merge($arrp, $arrn)) :
			(! empty($arrn) ? $defaultpage . '/' . join('/', $arrn) : $defaultpage);
	}

	return $name;
}
